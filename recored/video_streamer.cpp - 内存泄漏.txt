 video_streamer.cpp - 修复内存泄漏和播放问题
#include video_streamer.h
#include iostream
#include cstring
#include sstream

 FrameBuffer implementation (unchanged)
FrameBufferFrameBuffer(AVFrame frame)  pts(frame-pts) {
    size = frame-width  frame-height  3  2;
    data = new uint8_t[size];

    uint8_t dst = data;
    uint8_t src_y = frame-data[0];
    for (int i = 0; i  frame-height; i++) {
        memcpy(dst, src_y, frame-width);
        dst += frame-width;
        src_y += frame-linesize[0];
    }

    uint8_t src_u = frame-data[1];
    for (int i = 0; i  frame-height  2; i++) {
        memcpy(dst, src_u, frame-width  2);
        dst += frame-width  2;
        src_u += frame-linesize[1];
    }

    uint8_t src_v = frame-data[2];
    for (int i = 0; i  frame-height  2; i++) {
        memcpy(dst, src_v, frame-width  2);
        dst += frame-width  2;
        src_v += frame-linesize[2];
    }
}

FrameBuffer~FrameBuffer() {
    delete[] data;
}

bool initialize_gstreamer_with_diagnostics() {
    stdcout  === GStreamer Diagnostics ===  stdendl;

    if (gst_is_initialized()) {
        stdcout  GStreamer is already initialized.  stdendl;
    }
    else {
        stdcout  Initializing GStreamer...  stdendl;
        gst_init(nullptr, nullptr);
    }

    guint major, minor, micro, nano;
    gst_version(&major, &minor, &micro, &nano);
    stdcout  GStreamer Version   major  .  minor  .  micro  .  nano  stdendl;

    gst_debug_set_default_threshold(GST_LEVEL_WARNING);

    stdvectorstdstring core_plugins = {
        coreelements, videoconvert, videotestsrc, app, x264
    };

    for (const auto& plugin_name  core_plugins) {
        GstPlugin plugin = gst_plugin_load_by_name(plugin_name.c_str());
        if (plugin) {
            stdcout  Loaded plugin   plugin_name  stdendl;
            gst_object_unref(plugin);
        }
        else {
            stdcout  Failed to load plugin   plugin_name  stdendl;
        }
    }

    stdvectorstdstring test_elements = {
        appsrc, videoconvert, x264enc, rtph264pay, identity
    };

    bool all_available = true;
    for (const auto& element_name  test_elements) {
        GstElement element = gst_element_factory_make(element_name.c_str(), nullptr);
        if (element) {
            stdcout  [OK] Created element '  element_name  '  stdendl;
            gst_object_unref(element);
        }
        else {
            stdcout  [FAIL] Failed to create element '  element_name  '  stdendl;
            all_available = false;
        }
    }

    stdcout  =============================  stdendl;
    return all_available;
}

VideoStreamerVideoStreamer(const stdstring& rtp_ip, int rtp_port)
     ip_(rtp_ip), port_(rtp_port), width_(0), height_(0), fps_(0),
    server_(nullptr), mounts_(nullptr), factory_(nullptr), loop_(nullptr), appsrc_(nullptr),
    running_(false), initialized_(false), need_data_(true), frame_count_(0),
    dropped_frame_count_(0) {

    if (!initialize_gstreamer_with_diagnostics()) {
        stdcerr  GStreamer initialization warning some components may not be available.  stdendl;
    }
}

VideoStreamer~VideoStreamer() {
    stop();
}

bool VideoStreamerinit(int width, int height, int fps) {
    width_ = width;
    height_ = height;
    fps_ = fps;

    stdcout  [VideoStreamer] Initializing VideoStreamer (port   port_  )  stdendl;

    try {
        server_ = gst_rtsp_server_new();
        if (!server_) {
            stdcerr  Failed to create RTSP server.  stdendl;
            return false;
        }

        gst_rtsp_server_set_service(server_, stdto_string(port_).c_str());
        gst_rtsp_server_set_address(server_, ip_.c_str());

        mounts_ = gst_rtsp_server_get_mount_points(server_);
        factory_ = gst_rtsp_media_factory_new();
        if (!factory_) {
            stdcerr  Failed to create media factory.  stdendl;
            return false;
        }

        stdstring launch_desc = create_simple_pipeline();
        stdcout  Using pipeline   launch_desc  stdendl;

        gst_rtsp_media_factory_set_launch(factory_, launch_desc.c_str());
        gst_rtsp_media_factory_set_shared(factory_, TRUE);
        gst_rtsp_media_factory_set_latency(factory_, 50);

        g_signal_connect(factory_, media-configure, G_CALLBACK(media_configure_cb), this);
        gst_rtsp_mount_points_add_factory(mounts_, stream, factory_);

        guint server_id = gst_rtsp_server_attach(server_, nullptr);
        if (server_id == 0) {
            stdcerr  Failed to attach RTSP server.  stdendl;
            return false;
        }

        running_ = true;
        gst_thread_ = stdthread(&VideoStreamergstreamer_main_loop, this);
        push_thread_ = stdthread(&VideoStreamerpush_frame_loop, this);

        initialized_ = true;
        stdcout  RTSP server started successfully   get_rtsp_url()  stdendl;
        stdcout  Waiting for client connection to start streaming...  stdendl;
        return true;

    }
    catch (const stdexception& e) {
        stdcerr  Exception during RTSP initialization   e.what()  stdendl;
        return false;
    }
}

bool VideoStreamersend_frame(AVFrame frame) {
    if (!running_.load()  !initialized_) {
        return false;
    }

    if (frame-format != AV_PIX_FMT_YUV420P 
        frame-width != width_  frame-height != height_) {
        static int error_count = 0;
        if (error_count  5) {
            stdcerr  [send_frame] Frame formatsize mismatch 
                 format=  frame-format   (expected   AV_PIX_FMT_YUV420P  ), 
                 size=  frame-width  x  frame-height
                  (expected   width_  x  height_  )  stdendl;
            error_count++;
        }
        return false;
    }

     关键修复1：如果没有appsrc（即没有客户端连接），直接拒绝帧
    if (!appsrc_) {
        dropped_frame_count_++;
        if (dropped_frame_count_ % 1000 == 0) {
            stdcout  [send_frame] No client connected to port   port_
                 , dropped   dropped_frame_count_   frames total  stdendl;
        }
        return false;
    }

     关键修复2：检查need_data状态和队列大小，防止内存泄漏
    bool can_accept_frame = false;
    {
        stdlock_guardstdmutex lock(queue_mutex_);

         只有在以下情况下才接受新帧：
         1. GStreamer需要数据 (need_data_ == true)
         2. 或者队列未满
        if (need_data_.load()  frame_queue_.size()  MAX_FRAME_QUEUE_SIZE) {
            can_accept_frame = true;
        }
    }

    if (!can_accept_frame) {
         如果GStreamer不需要数据且队列已满，直接丢弃帧避免内存泄漏
        dropped_frame_count_++;

         每100帧提醒一次，避免日志刷屏
        if (dropped_frame_count_ % 100 == 0) {
            stdcout  [send_frame] Port   port_
                  - GStreamer backpressure, dropping frame. Total dropped 
                 dropped_frame_count_  stdendl;
        }
        return false;
    }

     创建FrameBuffer
    auto frame_buffer = stdmake_sharedFrameBuffer(frame);

    {
        stdlock_guardstdmutex lock(queue_mutex_);

         如果队列仍然满（双重检查），移除最旧的帧
        if (frame_queue_.size() = MAX_FRAME_QUEUE_SIZE) {
            frame_queue_.pop();
            dropped_frame_count_++;
        }

        frame_queue_.push(frame_buffer);
    }

    frame_count_++;
    queue_cv_.notify_one();

     详细的调试信息
    if (frame_count_ % 100 == 0) {
        stdlock_guardstdmutex lock(queue_mutex_);
        stdcout  [send_frame] Port   port_
             , accepted frame   frame_count_
             , dropped   dropped_frame_count_
             , queue size   frame_queue_.size()
             , need_data   need_data_.load()
             , appsrc   (appsrc_  VALID  NULL)  stdendl;
    }

    return true;
}

void VideoStreamerstop() {
    if (!running_.load()) {
        return;
    }

    stdcout  Stopping VideoStreamer (port   port_  )...  stdendl;
    running_ = false;
    initialized_ = false;

    queue_cv_.notify_all();

    if (loop_) {
        g_main_loop_quit(loop_);
    }

    if (gst_thread_.joinable()) {
        gst_thread_.join();
    }

    if (push_thread_.joinable()) {
        push_thread_.join();
    }

    if (mounts_) {
        g_object_unref(mounts_);
        mounts_ = nullptr;
    }

    if (server_) {
        g_object_unref(server_);
        server_ = nullptr;
    }

    if (loop_) {
        g_main_loop_unref(loop_);
        loop_ = nullptr;
    }

     清理队列并统计
    {
        stdlock_guardstdmutex lock(queue_mutex_);
        size_t remaining_frames = frame_queue_.size();
        while (!frame_queue_.empty()) {
            frame_queue_.pop();
        }
        if (remaining_frames  0) {
            stdcout  Cleared   remaining_frames   remaining frames from queue (port   port_  )  stdendl;
        }
    }

    appsrc_ = nullptr;
    stdcout  VideoStreamer (port   port_  ) stopped. Total frames 
         frame_count_  , dropped   dropped_frame_count_  stdendl;
}

stdstring VideoStreamerget_rtsp_url() const {
    return rtsp + ip_ +  + stdto_string(port_) + stream;
}

void VideoStreamergstreamer_main_loop() {
    loop_ = g_main_loop_new(nullptr, FALSE);
    if (loop_) {
        stdcout  Starting GStreamer main loop (port   port_  )...  stdendl;
        g_main_loop_run(loop_);
        stdcout  GStreamer main loop exited (port   port_  ).  stdendl;
    }
}

void VideoStreamerpush_frame_loop() {
    stdcout  Starting frame push thread (port   port_  )...  stdendl;

    int push_count = 0;
    int failed_push_count = 0;
    auto last_stats_time = stdchronosteady_clocknow();

    while (running_.load()) {
        bool has_appsrc = (appsrc_ != nullptr);
        bool needs_data = need_data_.load();

        if (has_appsrc && needs_data) {
            bool pushed = push_frame_to_appsrc();
            if (pushed) {
                push_count++;
            }
            else {
                failed_push_count++;
            }
        }
        else if (has_appsrc && !needs_data) {
             关键修复3：当GStreamer不需要数据时，清理一些积压的帧避免队列堆积
            {
                stdlock_guardstdmutex lock(queue_mutex_);
                if (frame_queue_.size()  MAX_FRAME_QUEUE_SIZE  2) {
                     清理一半队列，保持流畅性
                    size_t frames_to_drop = frame_queue_.size()  2;
                    for (size_t i = 0; i  frames_to_drop && !frame_queue_.empty(); i++) {
                        frame_queue_.pop();
                        dropped_frame_count_++;
                    }
                    if (frames_to_drop  0) {
                        stdcout  [push_frame_loop] Cleared   frames_to_drop
                              backlogged frames (port   port_  )  stdendl;
                    }
                }
            }
        }

         适当的睡眠时间
        stdthis_threadsleep_for(stdchronomilliseconds(5));

        auto current_time = stdchronosteady_clocknow();

         每5秒打印一次推送统计
        if (stdchronoduration_caststdchronoseconds(current_time - last_stats_time).count() = 5) {
            size_t queue_size;
            {
                stdlock_guardstdmutex lock(queue_mutex_);
                queue_size = frame_queue_.size();
            }

            stdcout  [push_frame_loop] Port   port_
                 , pushed   push_count   frames (failed   failed_push_count  )
                 , queue   queue_size    MAX_FRAME_QUEUE_SIZE
                 , need_data   needs_data
                 , appsrc   (has_appsrc  VALID  NULL)  stdendl;
            last_stats_time = current_time;
        }
    }

    stdcout  Frame push thread exited (port   port_  ), total pushed   push_count
         , failed   failed_push_count  stdendl;
}

bool VideoStreamerpush_frame_to_appsrc() {
    if (!appsrc_  !running_.load()) {
        return false;
    }

    stdshared_ptrFrameBuffer frame_buffer;

    {
        stdunique_lockstdmutex lock(queue_mutex_);
        if (frame_queue_.empty()) {
            return false;
        }
        frame_buffer = frame_queue_.front();
        frame_queue_.pop();
    }

    GstBuffer buffer = gst_buffer_new_allocate(nullptr, frame_buffer-size, nullptr);
    if (!buffer) {
        stdcerr  Failed to allocate GstBuffer.  stdendl;
        return false;
    }

    GstMapInfo map;
    if (gst_buffer_map(buffer, &map, GST_MAP_WRITE)) {
        memcpy(map.data, frame_buffer-data, frame_buffer-size);
        gst_buffer_unmap(buffer, &map);
    }
    else {
        stdcerr  Failed to map GstBuffer.  stdendl;
        gst_buffer_unref(buffer);
        return false;
    }

     修复4：改进时间戳处理，使用更稳定的时间基准
    static stdchronosteady_clocktime_point start_time = stdchronosteady_clocknow();
    auto current_time = stdchronosteady_clocknow();
    auto elapsed = stdchronoduration_caststdchrononanoseconds(current_time - start_time);

    GstClockTime timestamp = elapsed.count();
    GST_BUFFER_PTS(buffer) = timestamp;
    GST_BUFFER_DTS(buffer) = timestamp;
    GST_BUFFER_DURATION(buffer) = GST_SECOND  fps_;

    GstFlowReturn ret = gst_app_src_push_buffer(GST_APP_SRC(appsrc_), buffer);
    if (ret != GST_FLOW_OK) {
        static int error_count = 0;
        if (error_count  10) {
            stdcerr  Failed to push buffer to appsrc (port   port_  )   ret  stdendl;
            error_count++;
        }
        return false;
    }

    return true;
}

stdstring VideoStreamercreate_simple_pipeline() const {
    stdostringstream oss;
    oss  appsrc name=mysrc format=time is-live=true do-timestamp=false 
         caps=videox-raw,format=I420,width=  width_
         ,height=  height_
         ,framerate=  fps_  1 ! 
         queue max-size-buffers=3 leaky=downstream !    修复5：减少queue缓冲，提高响应性
         videoconvert ! 
         x264enc tune=zerolatency bitrate=2000 speed-preset=faster    修复6：使用faster预设提高编码速度
         key-int-max=30 bframes=0 ! 
         h264parse ! 
         rtph264pay name=pay0 pt=96 config-interval=1 mtu=1400;   修复7：设置MTU避免分片
    return oss.str();
}

void VideoStreamermedia_configure_cb(GstRTSPMediaFactory factory,
    GstRTSPMedia media,
    gpointer user_data) {
    VideoStreamer streamer = static_castVideoStreamer(user_data);

    stdcout  [media_configure] Client connected! Configuring media (port   streamer-port_  )  stdendl;

    GstElement pipeline = gst_rtsp_media_get_element(media);
    GstElement appsrc = gst_bin_get_by_name(GST_BIN(pipeline), mysrc);

    if (!appsrc) {
        stdcerr  Failed to find appsrc element.  stdendl;
        return;
    }

    streamer-appsrc_ = appsrc;

    g_object_set(G_OBJECT(appsrc),
        format, GST_FORMAT_TIME,
        is-live, TRUE,
        do-timestamp, FALSE,
        min-latency, G_GINT64_CONSTANT(0),
        max-latency, G_GINT64_CONSTANT(50000000),
        max-buffers, 3,   修复8：减少appsrc内部缓冲
        leaky-type, 2,    修复9：设置leaky模式，丢弃旧帧
        nullptr);

    g_signal_connect(appsrc, need-data, G_CALLBACK(need_data_cb), user_data);
    g_signal_connect(appsrc, enough-data, G_CALLBACK(enough_data_cb), user_data);

    gst_rtsp_media_set_latency(media, 50);

    stdcout  [media_configure] Media configured for port   streamer-port_
         , appsrc is now VALID  stdendl;
}

gboolean VideoStreamerneed_data_cb(GstElement appsrc,
    guint unused,
    gpointer user_data) {
    VideoStreamer streamer = static_castVideoStreamer(user_data);
    streamer-need_data_ = true;
    return TRUE;
}

void VideoStreamerenough_data_cb(GstElement appsrc, gpointer user_data) {
    VideoStreamer streamer = static_castVideoStreamer(user_data);
    streamer-need_data_ = false;
}

stdstring VideoStreamerffmpeg_errstr(int errnum) {
    return Error code  + stdto_string(errnum);
}